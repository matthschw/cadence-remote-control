(putpropq (quote EDcdsRC) (makeTable "session" nil) session) 
(setarray (getqq EDcdsRC session) "main" (list nil)) 
(putpropq (arrayref (getqq EDcdsRC session) "main") (makeTable "retVals" nil) retVals) 
(putpropq (arrayref (getqq EDcdsRC session) "main") 0 maxIndex) 
(defun EDcdsRCfmtCmd (result \@key (returnType "print") (session "main")) (let (retval (maxLength 4000) retstring port file) (setq retval (list nil)) (if result then (putpropq retval t valid) (putpropq retval (car result) data) (setq retstring (EDcdsRCbuildXML retval ?session session)) (when (geqp (strlen retstring) maxLength) (setq file (makeTempFileName "/tmp/ed_cds_rc")) (setq port (outfile file)) (fprintf port "%s" retstring) (close port) (putpropq retval nil data) (putpropq retval file file) (setq retstring (EDcdsRCbuildXML retval ?session session))) else (putpropq retval nil valid) (putpropq retval (getqq errset errset) error) (setq retstring (EDcdsRCbuildXML retval ?session session))) (if (equal returnType "print") then (printf retstring) else retstring))) 
(defun EDcdsRCexCmdFile (file \@key (returnType "print") (session "main")) (let (port command) (setq port (infile file)) (setq command (read port)) (close port) (EDcdsRCfmtCmd (errset (eval command)) ?returnType returnType ?session session))) 
(defun EDcdsRCbuildXML (content \@key (session "main")) (let (fTraverseDataStructure lBuildList (sRoot "root")) (setq lBuildList (tconc nil nil)) (tconc lBuildList "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n") (setq fTraverseDataStructure (lambda (val sRoot sIndentation) (let (idx) (cond ((fixp val) (tconc lBuildList (lsprintf "%s<%s type=\"fixnum\">%L</%s>\n" sIndentation sRoot val sRoot))) ((floatp val) (tconc lBuildList (lsprintf "%s<%s type=\"flonum\">%L</%s>\n" sIndentation sRoot val sRoot))) ((stringp val) (tconc lBuildList (lsprintf "%s<%s type=\"string\">%s</%s>\n" sIndentation sRoot (EDcdsRCescapeXML val) sRoot))) ((and (listp val) (null (car val))) (tconc lBuildList (lsprintf "%s<%s type=\"dpl\">\n" sIndentation (EDcdsRCescapeXML sRoot))) (foreach item (getq val ?) (funcall fTraverseDataStructure (get val item) item (strcat sIndentation "\t"))) (tconc lBuildList (lsprintf "%s</%s>\n" sIndentation (EDcdsRCescapeXML sRoot)))) ((listp val) (tconc lBuildList (lsprintf "%s<%s type=\"list\">\n" sIndentation (EDcdsRCescapeXML sRoot))) (foreach item val (funcall fTraverseDataStructure item "entry" (strcat sIndentation "\t"))) (tconc lBuildList (lsprintf "%s</%s>\n" sIndentation (EDcdsRCescapeXML sRoot)))) ((symbolp val) (tconc lBuildList (lsprintf "%s<%s type=\"symbol\">%s</%s>\n" sIndentation sRoot (EDcdsRCescapeXML (get_pname val)) sRoot))) (t (setq idx -1) (foreach id (getq (getq (arrayref (getqq EDcdsRC session) session) retVals) ?) (when (equal (arrayref (getq (arrayref (getqq EDcdsRC session) session) retVals) id) val) (setq idx id))) (when (equal idx -1) (setq idx (getq (arrayref (getqq EDcdsRC session) session) maxIndex)) (setarray (getq (arrayref (getqq EDcdsRC session) session) retVals) (getq (arrayref (getqq EDcdsRC session) session) maxIndex) val) (putpropq (arrayref (getqq EDcdsRC session) session) (plus (getq (arrayref (getqq EDcdsRC session) session) maxIndex) 1) maxIndex)) (tconc lBuildList (lsprintf "%s<%s type=\"complex\">%L</%s>\n" sIndentation sRoot idx sRoot))))))) (funcall fTraverseDataStructure content (if (or (stringp sRoot) (symbolp sRoot)) sRoot "root") "") (apply (quote strcat) (cdar lBuildList)))) 
(defun EDcdsRCescapeXML (sSequence) (buildString (foreach mapcar x (parseString sSequence "") (cond ((equal x "\"") "&quot;") ((equal x "'") "&apos;") ((equal x "<") "&lt;") ((equal x ">") "&gt;") ((equal x "&") "&amp;") (t x))) "")) 
